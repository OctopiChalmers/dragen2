\documentclass[conference, fleqn]{IEEEtran}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%




















% Local Variables:
% TeX-master: "main.lhs.tex"
% TeX-command-default: "Make"
% End:

\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

\usepackage{todonotes}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{mathdots}
\usepackage{yhmath}
\usepackage{cancel}
\usepackage{color}
\usepackage{siunitx}
\usepackage{array}
\usepackage{multirow}
\usepackage{amssymb}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{xspace}
\usepackage{relsize}
\usetikzlibrary{fadings}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros
\newcommand{\tocite}{\textbf{CITE}}
\newcommand{\quickcheck}{\emph{QuickCheck}\xspace}
\newcommand{\megadeth}{\emph{MegaDeTH}\xspace}
\newcommand{\dragen}{\textbf{DRAGEN}\xspace}

\newcommand{\evalrep}[2]{\ensuremath{\llbracket #1 \rrbracket_{#2}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Some parameters
\setlength{\mathindent}{1.5\parindent}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title
\title{Synthesizing Random Generators via Higher-Order Representations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Authors
\author{
  \IEEEauthorblockN{
    % 1\textsuperscript{st}
    Agust\'in Mista
  }
  \IEEEauthorblockA{
    % \textit{Department of Computer Science and Engineering} \\
    \textit{Chalmers University of Technology}\\
    Gothenburg, Sweden \\
    mista@chalmers.se
  }
\and
\IEEEauthorblockN{
  % 2\textsuperscript{nd}
  Alejandro Russo
  }
  \IEEEauthorblockA{
    % \textit{Department of Computer Science and Engineering} \\
    \textit{Chalmers University of Technology}\\
    Gothenburg, Sweden \\
    russo@chalmers.se
  }
}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract

\begin{abstract}

  Pellentesque dapibus suscipit ligula. Donec posuere augue in quam. Etiam vel
  tortor sodales tellus ultricies commodo. Suspendisse potenti. Aenean in sem ac
  leo mollis blandit. Donec neque quam, dignissim in, mollis nec, sagittis eu,
  wisi. Phasellus lacus. Etiam laoreet quam sed arcu. Phasellus at dui in ligula
  mollis ultricies. Mauris mollis tincidunt felis. Aliquam feugiat tellus ut
  neque. Nulla facilisis, risus a rhoncus fermentum, tellus tellus lacinia
  purus, et dictum nunc justo sit amet elit.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Keywords
\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Sections

\section{Introduction}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat\cite{grieco2017}.

The main contribuitions of this paper are:
%
\begin{itemize}
  %
\item We identify two patological scenarios for which standard type-driven
  automatic derivation tools fail to synthesize practical random generators, due
  to a lack of either type structure or domain knowleadge (Section
  \ref{sec:randomtesting}).
  %
\item We present a generation technique able to encode stronger properties of
  the target data type by reifying the static information present on the program
  codebase (Section \ref{sec:hrep}).
  %
\item We apply and extend the theory of branching processes to analitically
  predict the average distribution of generated values.
  %
  Furthermore, we use the predictions to perform simulation-based optimization
  of the random generation parameters (Section \ref{sec:synthesis}).
  %
\item We provide an implementation of our ideas in the form of a Haskell library
  to perform automatic derivation of random generators capable to extract useful
  structure information from the user source code.
  %
\end{itemize}
\section{Type-Driven Random Generation} \label{sec:randomtesting}

In this section we briefly describe the common technique used for automatically
deriving random data generators in Haskell using a type-driven approach.
%
Then, we introduce its main drawbacks by considering two scenarios where this
technique gives poor results in practice.
%
We remark that, altough this work makes focus on Haskell data types, this
technique is general enough to be applied to most programming languages with
some level of support for composite types.


Haskell is a strongly typed programming language with a powerful type system.
%
It lets programmers encode a considerable amount of information about the
properties of their systems using data types that can be checked at compilation
time.
%
One of its key aspects is the support for Algebraic Data Types (ADTs).
%
Essentially, an ADTs is a composite type defined by combining other types.
%
In the most basic conception, types can be combined by \textbf{sums} (also known
as \emph{variant types} or \emph{tagged disjoint unions}) and \textbf{products}
(or tuples) of other data types.
%
To exemplify this, consider the following definition of the data type \ensuremath{\Conid{Exp}}
encoding integer expressions:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Exp}{}\<[11]%
\>[11]{}\mathrel{=}{}\<[15]%
\>[15]{}\Conid{Val}\;{}\<[20]%
\>[20]{}\Conid{Int}{}\<[E]%
\\
\>[11]{}\;\;\vert\;{}\<[15]%
\>[15]{}\Conid{Add}\;{}\<[20]%
\>[20]{}\Conid{Exp}\;{}\<[25]%
\>[25]{}\Conid{Exp}{}\<[E]%
\\
\>[11]{}\;\;\vert\;{}\<[15]%
\>[15]{}\Conid{Mul}\;{}\<[20]%
\>[20]{}\Conid{Exp}\;{}\<[25]%
\>[25]{}\Conid{Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, we declare \ensuremath{\Conid{Exp}} as the sum of three possible
classes of values: \ensuremath{\Conid{Val}} represents literal values, whereas \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}
represent the addition and multiplication of two integer expressions,
respectively.
%
In Haskell, \ensuremath{\Conid{Val}}, \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}} are called \emph{data constructors} (or
constructors for short) and are used to distiguish which variant of the data
type we are reffering to.
%
Each data constructor is then defined as a product of zero or more types known
as \emph{fields}.
%
In particular, \ensuremath{\Conid{Val}} contains a field of type \ensuremath{\Conid{Int}}, while \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}
contain two fields of type \ensuremath{\Conid{Exp}} representing the operands of each operation.
%
Note that \ensuremath{\Conid{Exp}} is used as a field of at least one of its data constructors
(case \ensuremath{\Conid{Add}} and \ensuremath{\Conid{Mul}}), making it a recursively defined ADT.
%
In general, we will say that a data constructor with no recursive fields is
\emph{terminal}, and \emph{non-terminal} or \emph{recursive} if it has at least
one field of such nature.
%
With this reprentation, the expression ``2 + (5 * 6)'' can be encoded simply by
using \ensuremath{\Conid{Exp}} data constructors as \ensuremath{(\Conid{Add}\;(\Conid{Val}\;\mathrm{2})\;(\Conid{Mul}\;(\Conid{Val}\;\mathrm{5})\;(\Conid{Val}\;\mathrm{6})))}.
%
Furthermore, an evaluation function from \ensuremath{\Conid{Exp}}s to integer values can be defined
very idiomatically:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}c<{\hspost}@{}}%
\column{27E}{@{}l@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{eval}\mathbin{::}\Conid{Exp}\to \Conid{Int}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Val}\;\Varid{n}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{n}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Add}\;\Varid{x}\;\Varid{y}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{eval}\;\Varid{x}{}\<[27]%
\>[27]{}\mathbin{+}{}\<[27E]%
\>[30]{}\Varid{eval}\;\Varid{y}{}\<[E]%
\\
\>[B]{}\Varid{eval}\;(\Conid{Mul}\;\Varid{x}\;\Varid{y}){}\<[17]%
\>[17]{}\mathrel{=}\Varid{eval}\;\Varid{x}{}\<[27]%
\>[27]{}\mathbin{*}{}\<[27E]%
\>[30]{}\Varid{eval}\;\Varid{y}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, \ensuremath{\Varid{eval}} is described using \emph{pattern matching}
over each possible kind of value.
%
For the input case of a literal values, we simply return the value contained in
the \ensuremath{\Conid{Val}} constructor.
%
On the other hand, if the input value matches either an \ensuremath{\Conid{Add}} or a \ensuremath{\Conid{Mul}} data
constructor, where \ensuremath{\Varid{x}} and \ensuremath{\Varid{y}} are \emph{pattern variables} that match any
subexpression, we recursively evaluate these subexpressions, combining them with
the apropiate operation on each case.

\subsection*{\textbf{Type-Driven Generation of Random Values}}

In order to perform random testing of a Haskell codebase involving user defined
data types, most approaches require the user to provide a random data generator
for each one of them.
%
This tends to be a cumbersome and error prone task that closely follows the data
type structure.
%
For instance, consider the following definition of a \quickcheck random
generator for the type \ensuremath{\Conid{Exp}}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}c<{\hspost}@{}}%
\column{6E}{@{}l@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}gen_{Exp}\mathrel{=}\Varid{sized}\;(\lambda \Varid{size}\to {}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{if}\;\Varid{size}\equiv \mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{then}\;\Conid{Val}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{arbitrary}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\mathbf{else}\;\Varid{frequency}{}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{}[\mskip1.5mu {}\<[6E]%
\>[9]{}(\mathrm{1},\Conid{Val}{}\<[18]%
\>[18]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{arbitrary}){}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{},{}\<[6E]%
\>[9]{}(\mathrm{2},\Conid{Add}{}\<[18]%
\>[18]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{Exp}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{Exp}){}\<[E]%
\\
\>[4]{}\hsindent{2}{}\<[6]%
\>[6]{},{}\<[6E]%
\>[9]{}(\mathrm{1},\Conid{Mul}{}\<[18]%
\>[18]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{Exp}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{Exp})\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

This random generator is defined using \quickcheck's combinator \ensuremath{\Varid{sized}} to
paremetrize the generation process up to an external integer number known as the
\emph{generation size}.
%
This parameter is used to limit the maximum amount of recursive call that this
random generator can perform.
%
When called with a positive generation size (case \ensuremath{\Varid{gen}\;\Varid{n}}), the generator will
pick among any data constructor of \ensuremath{\Conid{Exp}} with a explicitly given frequency---two
times more \ensuremath{\Conid{Add}}s than \ensuremath{\Conid{Val}} or \ensuremath{\Conid{Mul}}.
%
In the case it picks to generate a \ensuremath{\Conid{Val}} data constructor, it also generates a
random \ensuremath{\Conid{Int}} value using the standard overloaded generator \ensuremath{\Varid{arbitrary}}
(\quickcheck provides standard random generators for most base types like \ensuremath{\Conid{Int}},
\ensuremath{\Conid{Bool}}, etc.).
%
On the other hand, when it randomly picks to generate either an \ensuremath{\Conid{Add}} or a \ensuremath{\Conid{Mul}}
data constructor, it also generates independently two random subexpressions
corresponding to the data constructor fields by calling itself recursively
(\ensuremath{\Varid{resize}\;(n{-}1)\;gen_{Exp}}), decreasing the generation size on each recursive
invocation.


This procedure keeps calling itself recursively until the generation size
reaches zero (case \ensuremath{\Varid{gen}\;\mathrm{0}}), where the generator is constrained to pick only
among terminal data constructors, being \ensuremath{\Conid{Val}} the only possible choice in our
particular case.
%
Strictly decreasing the the generation size by one on each recursive call
results in a useful property over the generated data: every generated value has
at most \ensuremath{\Varid{n}} levels, where \ensuremath{\Varid{n}} is the generation size set by the user.
%
This property enables us to model the generation process using the theory of
branching processes introduced by \tocite, and extended in this work as
described in Section \ref{sec:synthesis}.


Having discussed the previous random generator definition, it easy to understand
how to extend this generation procedure to any data type defined in an algebraic
fashion.
%
Fortunately, there exists different meta-programming tools to avoid the user
from having to mechanically write random generators over and over again for each
user-defined ADT.
%
The simplest tool for such purpose is \megadeth.
%
Given the name of the target data type, it synthesizes a random generator for it
that behaves pretty much like the previously defined one.
%
However, picking among different data constructors with uniform probability can
lead to a generation process biased to generate (in average) very small values,
regardless of the generation sized set by the user \tocite.

\dragen is meta-programming tool conceived to mitigate this problem.
%
Instead of setting a uniform generation probability of data constructors, this
tool considers the scenario where each one can be generated following a
different (although fixed over time) generation probability.
%
Then, this tool uses the theory of branching processes to analitically predict
the average distribution of data constructors generated on each random value.
%
This prediction mechanism is used to feedback a simulation-based optimization
process that adjusts the generation probability of each data constructor in
order to obtain a particular distribution of values that can be specified by the
user, offering a more flexible testing environment while still being mostly
automated.


Both \megadeth and \dragen synthesize random generators that are theoretically
capable to generate the whole space of values of the target data type, provided
that we set a generation size suficiently big.
%
However, the limitations arise quickly when we consider that the underlying
generation model is essentially the same: they pick a single data constructor
and recusively generate each required subexpression independently.
%
In practice, this procedure is too generic to generate complex data that is
useful enough to be used for random testing.


In this work we identify two sources of additional structure information which
are not considered by the aforementioned automatic derivation tools to obtain
random data generators:

\begin{enumerate}
\item The target code behaves differently over inputs matching very specific
  patterns.
\item The target code yields part of the responsability of preserving its
  invariants to the functions of its abstract interface.
\end{enumerate}

This information can be reified in compile time and used to synthesize richer
random generators automatically. We proceed to exemplify the previous points in
detail.

\subsection*{\textbf{Presence of Complex Pattern Matchings}}

To exemplify the firts problematic scenarion that may arise, suppose we want to
use randomly generated \ensuremath{\Conid{Exp}}s to test a property comprising the following
function:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{foo}\mathbin{::}\Conid{Exp}\to \Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;(\Conid{Add}\;(\Conid{Add}\;\Varid{x}\;(\Conid{Val}\;\mathrm{50}))\;(\Conid{Add}\;(\Conid{Val}\;\mathrm{25})\;\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{error}\;\text{\ttfamily \char34 pattern~\#1\char34}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;(\Conid{Mul}\;(\Conid{Val}\;\mathrm{50})\;(\Conid{Mul}\;(\Conid{Val}\;\Varid{x})\;\Varid{y})){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{error}\;\text{\ttfamily \char34 pattern~\#2\char34}{}\<[E]%
\\
\>[B]{}\Varid{foo}\;\Varid{x}\mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This function behaves very much like an identity function, with the exception
that it fails for two very specific patterns of input values defined using
nested pattern matching.
%
This is, \ensuremath{\Varid{foo}} does not only matches against the root data constructor, but also
against the data constructors of its subexpressions and sub-subexpressions.


\quickcheck's default implementation for random \ensuremath{\Conid{Int}}s pick a number in the
interval $[-n, n]$ with uniform distribution.
%
Hence, in principle we need to recognize what is a suitable generation size,
which should be big enough for our generator be able to generate the numbers we
pattern match against to, otherwise we will not be able to generate any value to
match against \ensuremath{\Varid{foo}} clauses, leaving fragments of code completely untested.
%
Suppose then that we pick the a generation size $50$, i.e. the minimum size that
is big enough to produce an \ensuremath{\Conid{Int}} number equal to $50$.
%
Under this consideration, the probability of generating a value matching the
first clause of \ensuremath{\Varid{foo}} (and hence triggering the first error) results as follows:
%
\begin{align*}
  &P(match(foo\#1))\\
  &\quad = P(Add)       * P(Add) * 1 * (P(Val) * (1/100)) \\
  &\phantom{xxxxxxxxxx} * P(Add) * (P(Val) * (1/100)) * 1
\end{align*}

If we use \megadeth to automatically derive a random generator for \ensuremath{\Conid{Exp}}, we
obtain a uniform generation probability distribution over constructors, i.e.,
$P(\ensuremath{\Conid{Val}}) = P(\ensuremath{\Conid{Add}}) = P(\ensuremath{\Conid{Mul}}) = 1/3$.
%
In this setting, $P(match(foo\#1))$ results $1/2430000$, meaning that, in
average, we will need to generate over than two million test cases in order to
be able to test the first clause of \ensuremath{\Varid{foo}} only once.
%
This situation can be somewhat improved if we use \dragen to obtain a random
generator.
%
Using this tool, we can optimize the generation probabilities in order to
benefit the generation of some data constructors over the rest.
%
Considering that the first pattern matching of \ensuremath{\Varid{foo}} involves the data
constructor \ensuremath{\Conid{Add}} as the only recursive one, we can set an target generation
proportion of \ensuremath{\Conid{Add}} data constructors of, for instance, $20:1$ with respect to
the rest of the generated data constructors.
%
By doing so, the obtained distribution of values results such that
$P(match(foo\#1)) \approx 1/300000$.
%
Although this certainly improves the probability of generating a matching value,
this probability is not substantial enough to become practical.


Additionally, by favoring the generation probabilities towards the \ensuremath{\Conid{Add}}
constructor, we found that the probability of generating a value matching the
second clause of \ensuremath{\Varid{foo}} (which does not matches against it) also gets diminished
into an impractival value.


Despite the fact that the previous example might look artificial, branching
against specific patterns of the input data is a common task.
%
For instance, the balancing function of a Red-Black tree need to consider a
quite specific combination of color, left and right subtrees and sub-subtrees
in order to preserve the height invariant.
%
Moreover, Common Subexpression Elimination (CSE) is a compiler optimization that
needs to consider very specific sequences of instructions that may be regrouped
in a computationally more efficient way, to cite a few.



\subsection*{\textbf{Data Invariants Encoded on Abstract Interfaces}}

A common choice when implementing a data structure is to transfer the
responsability of preserving its invariants to the functions that manipulates
its values.
%
Consider for instance the following possible implementation of a basic \ensuremath{\Conid{HTML}}
manipulation library:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{Html}\mathrel{=}\Conid{Html}\;\Conid{String}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{head}\mathbin{::}\Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{head}\;(\Conid{Html}\;\Varid{inner}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Conid{Html}\;(\text{\ttfamily \char34 <head>\char34}\plus \Varid{inner}\plus \text{\ttfamily \char34 </head>\char34}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{body}\mathbin{::}\Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{body}\;(\Conid{Html}\;\Varid{inner}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Conid{Html}\;(\text{\ttfamily \char34 <body>\char34}\plus \Varid{t}\plus \text{\ttfamily \char34 </body>\char34}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{br}\mathbin{::}\Conid{Html}{}\<[E]%
\\
\>[B]{}\Varid{br}\mathrel{=}\Conid{Html}\;\text{\ttfamily \char34 <br~/>\char34}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}(\mathop{\langle\! +\! \rangle})\mathbin{::}\Conid{Html}\to \Conid{Html}\to \Conid{Html}{}\<[E]%
\\
\>[B]{}(\Conid{Html}\;\Varid{x})\mathop{\langle\! +\! \rangle}(\Conid{Html}\;\Varid{y})\mathrel{=}\Conid{Html}\;(\Varid{x}\plus \Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition, the \ensuremath{\Conid{Html}} data type is defined using a single data
constructor that contains the textual representation of the Html code it
represents in plain text.
%
Later, the combinator functions defined over \ensuremath{\Conid{HTML}} are the ones in charge of
transforming this plain text representation with the invariant that, given valid
\ensuremath{\Conid{Html}} parameters, they always return a valid \ensuremath{\Conid{Html}} value.
%
This is a very commmon programming pattern that can be found in a variety of
Haskell libraries \tocite{}.


If we use a standard type-driven approach to derive a random generator for
\ensuremath{\Conid{Html}}, the only ``structural'' information that we can use in the derivation
process is that \ensuremath{\Conid{Html}} values are composed of strings.
%
As a consequence, we essentially end up generating random strings, which rarely
represents a valid (or at least well structured) Html value.
%
Additionally, if our test suite contains properties constrained by certain
preconditions, this lack of domain knowleadge may lead in an impractically high
discard ratio of randomly generated test.
%
For instance, suposse we write a property to verify that \ensuremath{\Varid{head}} preserves the
invariant previously mentioned:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{prop\char95 head\char95 inv}\mathbin{::}\Conid{Html}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{prop\char95 head\char95 inv}\;\Varid{x}\mathrel{=}\Varid{valid}\;\Varid{x}\Longrightarrow\Varid{valid}\;(\Varid{head}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

In the previous definition we state that \ensuremath{\Varid{head}} always returns a valid \ensuremath{\Conid{Html}}
value (\ensuremath{\Varid{valid}\;(\Varid{head}\;\Varid{x})}), provided that we are given a valid \ensuremath{\Conid{Html}} as input
(\ensuremath{\Varid{valid}\;\Varid{x}}).
%
Then, while testing this property we rarely satisfy its precondition, in which
case \quickcheck discards the whole test, retrying with a diferent random input,
degradating this way the testing performance.


We believe that, if certain patterns of values are relevant enough to appear in
the codebase being tested, a practical random testing methodology should be able
to produce values satisfying such patterns in a substantial proportion.
%
The next section introduces a reprentation model that let us encode the
structure information presented here into our automatically derived random
generators in a modular and flexible way.
\section{Extracting Structure} \label{sec:hrep}

In this section we present a compositional representation to express the random
generation of values following the internal structure of their data types along
with the structure present on patterns matchings and abstract interfaces.


The key idea of this work is to represent different sources of structured value
information of a data type in a homogeneous way that we call a ``higher-level
representation'' (\ensuremath{\text{HRep}} from now on).%
\footnote{The notion of higher-level comes from that the generation process of
  given target data type is entirely determined by the type of the chosen
  representation, instead of by a concrete generator defined at the term level.}
%
For this purpose, we use a series of automatically derived data types, each one
representing an atomic unit of information that can be randomly generated and
then reflected back to the corresponding value of the original data type.
%
Later, the user can compose these atomic representations using the provided type
level combinators in different ways into a ``generation specification'' that
completely determines the generation process.


We wil reuse the previously defined data type \ensuremath{\Conid{Exp}} and the function \ensuremath{\Varid{foo}} to
explain the different concepts involved all across this section.


\subsection*{\textbf{Representing Data Constructors}}

We begin by introducing the simplest data type representation that we can
extract from our codebase: the representation of single data constructor.
%
Each data constructor can be represented by an automatically derived data type
consisting of a single constructor with the same fields as the original, except
for the recursive ones that are abstracted away.
%
In this light, we represent each constructor of the data type \ensuremath{\Conid{Exp}} as follows:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{Val}\;{}\<[16]%
\>[16]{}\Varid{r}\mathrel{=}\text{Mk}_{Val}\;\Conid{Int}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{Add}\;{}\<[16]%
\>[16]{}\Varid{r}\mathrel{=}\text{Mk}_{Add}\;\Varid{r}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{Mul}\;{}\<[16]%
\>[16]{}\Varid{r}\mathrel{=}\text{Mk}_{Mul}\;\Varid{r}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Note that the previous definitions are type parametric over the type parameter
\ensuremath{\Varid{r}}.
%
This allow us to replace \ensuremath{\Varid{r}} with any concrete data type, obtaining different
possible values on each case.
%
For instance, the value (\ensuremath{\text{Mk}_{Add}\;\mathrm{10}\;\mathrm{20}}) has type \ensuremath{\text{HRep}_{Add}\;\Conid{Int}}, while the
value (\ensuremath{\text{Mk}_{Mul}\;\Conid{True}\;\Conid{False}}) has type \ensuremath{\text{HRep}_{Mul}\;\Conid{Bool}}.
%
In practice, this parametricity let us instatiate \ensuremath{\Varid{r}} with the type of the
chosen generation specification (which might be composed of several \ensuremath{\text{HRep}}s),
without having to modify anything in the underlying machinery.


Having the \ensuremath{\text{HRep}} of each data constructor, we can define an evaluation relation
($\evalrep{\_}{t} : \ensuremath{\text{HRep}}_f \rightarrow t$) that maps a value from each
representation \ensuremath{\Varid{f}} back to the target data type \ensuremath{\Varid{t}}.
%
Then, we simply need to translate each constructor representation back into its
corresponding one, translating the abstracted fields recursively:
%
\begin{alignat*}{4}
  &\evalrep{\ensuremath{\text{Mk}_{Val}}\ n\ \ \ &&}{\ensuremath{\Conid{Exp}}}
    &&= \ensuremath{\Conid{Val}}\ n \\
  &\evalrep{\ensuremath{\text{Mk}_{Add}}\ x\ y   &&}{\ensuremath{\Conid{Exp}}}
    &&= \ensuremath{\Conid{Add}}\ \evalrep{x}{Exp}\ \evalrep{y}{Exp} \\
  &\evalrep{\ensuremath{\text{Mk}_{Mul}}\ x\ y   &&}{\ensuremath{\Conid{Exp}}}
    &&= \ensuremath{\Conid{Mul}}\ \evalrep{x}{Exp}\ \evalrep{y}{Exp}
\end{alignat*}

The last missing piece is to automatically derive a random generators for each
constructor \ensuremath{\text{HRep}}.
%
For this purpose, it is important to consider that each constructor \ensuremath{\text{HRep}} has
its recursive fields abstracted away with a type parameter that will be later
instantiated with the generation specification type.
%
Given that this specification is unknown at the derivation time, we parametrize
each \ensuremath{\text{HRep}} generator with a random generator \ensuremath{gen_{r}} that is used to generate
each recursive fields:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}gen_{Val}\;{}\<[12]%
\>[12]{}gen_{r}{}\<[19]%
\>[19]{}\mathrel{=}\text{Mk}_{Val}{}\<[29]%
\>[29]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{arbitrary}{}\<[E]%
\\
\>[3]{}gen_{Add}\;{}\<[12]%
\>[12]{}gen_{r}{}\<[19]%
\>[19]{}\mathrel{=}\text{Mk}_{Add}{}\<[29]%
\>[29]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{r}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\\
\>[3]{}gen_{Mul}\;{}\<[12]%
\>[12]{}gen_{r}{}\<[19]%
\>[19]{}\mathrel{=}\text{Mk}_{Mul}{}\<[29]%
\>[29]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{r}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$


\subsection*{\textbf{Type Level Combinators}}

In this work we define type level combinators which let the user combine the
automatically derived \ensuremath{\text{HRep}}s in several ways.
%
In first place, we define a type combinator ($\_^\bullet$) to tag a \ensuremath{\text{HRep}} to be
terminal, i.e., a representation that is allowed be generated when the
generation size gets exausted:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(f^\bullet)\;\Varid{a}\mathrel{=}\Conid{Term}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Additionally, we define a combinator ($\otimes$) to tag a \ensuremath{\text{HRep}} with an
explicit generation frequency $n$:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(\Varid{f}\;\otimes\;\Varid{n})\;\Varid{a}\mathrel{=}\Conid{Freq}\;(\Varid{f}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The previous combinators only include information relevant to the generation
process, in a sense that neither one adds new structure to the final
representation.
%
In this light, they do not alter the evaluation semantics, and we translate them
back to our target data type by evaluating the inner representation:
%
\begin{alignat*}{4}
  &\evalrep{Freq\ x &&: f \otimes n &&}{t} &&= \evalrep{x : f}{t} \\
  &\evalrep{Term\ x &&: \ensuremath{f^\bullet}    &&}{t} &&= \evalrep{x : f}{t}
\end{alignat*}

In the previous equations we explicitly annotate (using a colon) the type of the
evaluated term for clarity.
%
Later, to generate these combinators is enough to wrap a generated value from
the inner representation with the apropriate tag:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}gen_{f^\bullet}\;{}\<[16]%
\>[16]{}gen_{r}{}\<[23]%
\>[23]{}\mathrel{=}\Conid{Term}{}\<[31]%
\>[31]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{f}\;gen_{r}{}\<[E]%
\\
\>[B]{}gen_{f \otimes n}\;{}\<[16]%
\>[16]{}gen_{r}{}\<[23]%
\>[23]{}\mathrel{=}\Conid{Freq}{}\<[31]%
\>[31]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{f}\;gen_{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


Perhaps more interesting, we define a combinator $(\oplus)$ to compose two
\ensuremath{\text{HRep}}s into a single one using a sum type and representing a random choice
between them:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;(\Varid{f}\;\oplus\;\Varid{g})\;\Varid{a}\mathrel{=}\Conid{L}\;(\Varid{f}\;\Varid{a})\mid \Conid{R}\;(\Varid{g}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A composite representation built using $(\oplus)$ is transformed back into the
target data type by pattern matching on the data type variant and evaluating the
inner \ensuremath{\text{HRep}}:
%
\begin{alignat*}{3}
  &\evalrep{L\ x &&: f \oplus g}{t} = \evalrep{x : f &&}{t} \\
  &\evalrep{R\ x &&: f \oplus g}{t} = \evalrep{y : g &&}{t}
\end{alignat*}

Generating a composite \ensuremath{\text{HRep}} is slightly more complicated than before, as we
need to perform a random choice based on the generation size and the given
frequencies for each sub-represention:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}gen_{f \oplus g}\;gen_{r}{}\<[23]%
\>[23]{}\mathrel{=}\Varid{sized}\;(\lambda \Varid{size}\to {}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{if}\;\Varid{size}\equiv \mathrm{0}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{then}\;\Varid{frequency}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}[\mskip1.5mu (\Varid{freq0}\;{}\<[17]%
\>[17]{}\textit{@}\!f,{}\<[24]%
\>[24]{}\Conid{L}{}\<[27]%
\>[27]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{f}\;{}\<[38]%
\>[38]{}gen_{r}{}\<[45]%
\>[45]{}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},(\Varid{freq0}\;{}\<[17]%
\>[17]{}\textit{@}\!g,{}\<[24]%
\>[24]{}\Conid{R}{}\<[27]%
\>[27]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{g}\;{}\<[38]%
\>[38]{}gen_{r}{}\<[45]%
\>[45]{})\mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{else}\;\Varid{frequency}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}[\mskip1.5mu (\Varid{freq}\;{}\<[17]%
\>[17]{}\textit{@}\!f,{}\<[24]%
\>[24]{}\Conid{L}{}\<[27]%
\>[27]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{f}\;{}\<[38]%
\>[38]{}gen_{r}{}\<[45]%
\>[45]{}){}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{},(\Varid{freq}\;{}\<[17]%
\>[17]{}\textit{@}\!g,{}\<[24]%
\>[24]{}\Conid{R}{}\<[27]%
\>[27]{}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{g}\;{}\<[38]%
\>[38]{}gen_{r}{}\<[45]%
\>[45]{})\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

The previous definition we reflect the type level frequencies of \ensuremath{\Varid{f}} and \ensuremath{\Varid{g}}
(\ensuremath{\Varid{freq}\;\textit{@}\!f} and \ensuremath{\Varid{freq}\;\textit{@}\!g}).
%
This frequency reflection defaults to $1$ if no frequency tag ($\otimes$) is
used.
%
Then we use these frequencies to generate each inner \ensuremath{\text{HRep}} in the apropriate
proportion.
%
When the generation size gets exhausted, we reflect the terminal generation
frequency of each inner \ensuremath{\text{HRep}} in the same way as before (\ensuremath{\Varid{freq0}\;\textit{@}\!f} and
\ensuremath{\Varid{freq0}\;\textit{@}\!g}).
%
This time, however, we default the frequency reflection to $0$ for any inner
that not tagged as terminal, avoiding to generate non-terminal constructions in
the last step.


With the introduced combinators, we can easily create a type synonym \ensuremath{\text{HRep}_{Exp}}
to specify a generation schema equivalent to the one seen in the concrete random
generator of type \ensuremath{\Conid{Exp}} presented in Section \ref{sec:randomtesting}:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{Exp}{}\<[16]%
\>[16]{}\mathrel{=}{}\<[24]%
\>[24]{}\text{HRep}_{Val}^\bullet{}\<[E]%
\\
\>[16]{}\!\;\oplus\;{}\<[24]%
\>[24]{}\text{HRep}_{Add}\;{}\<[34]%
\>[34]{}\otimes\;\mathrm{2}{}\<[E]%
\\
\>[16]{}\!\;\oplus\;{}\<[24]%
\>[24]{}\text{HRep}_{Mul}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

However, a value of type \ensuremath{\text{HRep}_{Exp}} still has its recursive calls abstracted
away---the type parameter \ensuremath{\Varid{r}} is implicit in the definition of \ensuremath{\text{HRep}_{Exp}}.
%
If we want to generate recursive values using this representation we need to
introduce a last type level combinator to ``tie the knot'' recursively:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{data}\;\Conid{Fix}\;\Varid{f}\mathrel{=}\Conid{Fix}\;(\Varid{f}\;(\Conid{Fix}\;\Varid{f})){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This datatype represents the \emph{fixed point} of a parametric data type \ensuremath{\Varid{f}},
i.e., a data type where each recursive call gets instantiated with iself.
%
To translate fixed points back to our target data type we simply need translate
the inner representation:
%
\begin{align*}
  \evalrep{Fix\ x : Fix\ f}{t} = \evalrep{x : f}{t}
\end{align*}
%
Categorically, this generic transformation of fixed points is called a
\emph{catamorphism}, where our evaluation relation is known as its
\emph{algebra}.


Unlike the other combinators, to randomly generate a fixed point of a certain
representation \ensuremath{\Varid{f}}, we do not parametrize the generation of the recursive fields
of the inner represention over an external generator \ensuremath{gen_{r}}.
%
Instead, we can also tie the recursive knot in our random generator by piping
the generation of the inner \ensuremath{\text{HRep}} parametrized recursively by the itself:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}genFix_{f}\mathrel{=}\Conid{Fix}\mathop{\mathsmaller{\langle \$ \rangle}}gen_{f}\;genFix_{f}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

This way we obtain a concrete recursive generator for each representation \ensuremath{\Varid{f}}
that we define.
%
With this generator, we can define a random generator for our target data type
simply by evaluating a random value of the representation:


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}gen_{Exp}\mathrel{=}\mathbf{do}\;{}\<[17]%
\>[17]{}\Varid{x}\leftarrow genFix_{(\text{HRep}\,{Exp})}{}\<[E]%
\\
\>[17]{}\Varid{return}\;\evalrep{x}{Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$


\subsection*{\textbf{Representing Pattern Matchings}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{foo\#1}\;{}\<[18]%
\>[18]{}\Varid{r}\mathrel{=}\text{Mk}_{foo\#1}\;\Varid{r}\;\Varid{r}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{foo\#2}\;{}\<[18]%
\>[18]{}\Varid{r}\mathrel{=}\text{Mk}_{foo\#2}\;\Conid{Int}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{align*}
  &\evalrep{\ensuremath{\text{Mk}_{foo\#1}}\ x\ y}{Exp} = \\
  &\ \ \ensuremath{\Conid{Add}\;(\Conid{Add}\;\evalrep{x}{Exp}\;(\Conid{Val}\;\mathrm{50}))\;(\Conid{Add}\;(\Conid{Val}\;\mathrm{25})\;\evalrep{y}{Exp})}\\
  &\evalrep{\ensuremath{\text{Mk}_{foo\#2}}\ x\ y}{Exp} = \\
  &\ \ \ensuremath{\Conid{Mul}\;(\Conid{Val}\;\mathrm{50})\;(\Conid{Mul}\;(\Conid{Val}\;\Varid{x})\;\evalrep{y}{Exp})}
\end{align*}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{52}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}gen_{foo\#1}\;{}\<[14]%
\>[14]{}gen_{r}{}\<[21]%
\>[21]{}\mathrel{=}\text{Mk}_{foo\#1}{}\<[33]%
\>[33]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{r}{}\<[52]%
\>[52]{}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\\
\>[3]{}gen_{foo\#2}\;{}\<[14]%
\>[14]{}gen_{r}{}\<[21]%
\>[21]{}\mathrel{=}\text{Mk}_{foo\#2}{}\<[33]%
\>[33]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{arbitrary}{}\<[52]%
\>[52]{}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{foo}{}\<[16]%
\>[16]{}\mathrel{=}\text{HRep}_{foo\#1}\;\!\!\oplus\!\!\;{}\<[38]%
\>[38]{}\text{HRep}_{foo\#2}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{\textbf{Representing Abstract Interfaces}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{module}\;\Conid{M}\;\mathbf{where}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{ten}\mathbin{::}\Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{ten}\mathrel{=}\Conid{Val}\;\mathrm{10}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{square}\mathbin{::}\Conid{Exp}\to \Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{square}\;\Varid{x}\mathrel{=}\Conid{Mul}\;\Varid{x}\;\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{minus}\mathbin{::}\Conid{Exp}\to \Conid{Exp}\to \Conid{Exp}{}\<[E]%
\\
\>[B]{}\Varid{minus}\;\Varid{x}\;\Varid{y}\mathrel{=}\Conid{Add}\;\Varid{x}\;(\Conid{Mul}\;\Varid{y}\;(\Conid{Val}\;(\mathbin{-}\mathrm{1}))){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\text{HRep}_{ten}\;{}\<[21]%
\>[21]{}\Varid{r}\mathrel{=}\text{Mk}_{ten}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{square}\;{}\<[21]%
\>[21]{}\Varid{r}\mathrel{=}\text{Mk}_{square}\;{}\<[37]%
\>[37]{}\Varid{r}{}\<[E]%
\\
\>[B]{}\mathbf{data}\;\text{HRep}_{minus}\;{}\<[21]%
\>[21]{}\Varid{r}\mathrel{=}\text{Mk}_{minus}\;{}\<[37]%
\>[37]{}\Varid{r}\;\Varid{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{alignat*}{3}
  &\evalrep{\ensuremath{\text{Mk}_{ten}}         &&}{Exp} = \ensuremath{\Varid{ten}} \\
  &\evalrep{\ensuremath{\text{Mk}_{square}}\ x   &&}{Exp} = \ensuremath{\Varid{square}\;\evalrep{x}{Exp}} \\
  &\evalrep{\ensuremath{\text{Mk}_{minus}}\ x\ y &&}{Exp} = \ensuremath{\Varid{minus}\;\evalrep{x}{Exp}\;\evalrep{y}{Exp}}
\end{alignat*}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{54}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}gen_{ten}\;{}\<[15]%
\>[15]{}gen_{r}{}\<[22]%
\>[22]{}\mathrel{=}\text{Mk}_{ten}{}\<[E]%
\\
\>[3]{}gen_{square}\;{}\<[15]%
\>[15]{}gen_{r}{}\<[22]%
\>[22]{}\mathrel{=}\text{Mk}_{square}{}\<[35]%
\>[35]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\\
\>[3]{}gen_{minus}\;{}\<[14]%
\>[14]{}gen_{r}{}\<[22]%
\>[22]{}\mathrel{=}\text{Mk}_{minus}{}\<[35]%
\>[35]{}\mathop{\mathsmaller{\langle \$ \rangle}}\Varid{smaller}\;gen_{r}{}\<[54]%
\>[54]{}\mathop{\mathsmaller{\langle \ast \rangle}}\Varid{smaller}\;gen_{r}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
 %$

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\text{HRep}_{M}{}\<[14]%
\>[14]{}\mathrel{=}\text{HRep}_{ten}\;\!\!\oplus\!\!\;{}\<[34]%
\>[34]{}\text{HRep}_{square}\;\!\!\oplus\!\!\;{}\<[55]%
\>[55]{}\text{HRep}_{minus}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{30}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Spec}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[20]%
\>[20]{}\text{HRep}_{Exp}\;{}\<[30]%
\>[30]{}\otimes\;\mathrm{4}{}\<[E]%
\\
\>[12]{}\!\;\oplus\;{}\<[20]%
\>[20]{}\text{HRep}_{foo}\;{}\<[30]%
\>[30]{}\otimes\;\mathrm{2}{}\<[E]%
\\
\>[12]{}\!\;\oplus\;{}\<[20]%
\>[20]{}\text{HRep}_{M}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

This previous definition can be interpreted graphically as it is shown in the
Figure \ref{fig:hrep}.
%
Curly arrows represent the structural information extracted using
meta-programming.

\begin{figure}[t]
  \centering
  \input{tikz/hrep.tex}
  \caption{Higher level representation of the data type \ensuremath{\Conid{Exp}}, defined using
    structural information from the function \ensuremath{\Varid{foo}} and the abstract interface of
    the module \ensuremath{\Conid{M}}.}
  \label{fig:hrep}
\end{figure}

% \begin{align*}
%   \llbracket \_ \rrbracket_{target}\ :\ rep_{target}\ \rightarrow\ target
% \end{align*}
%
% \begin{code}
% class (rep down target) where
%   step :: rep target -> target
% \end{code}
%
% \begin{code}
% data (Term f) a = TagTerm (f a)

% \begin{code}
% instance (HRep_Val down Exp) where
%   step (Mk_Val n) = Val n

% instance (HRep_Add down Exp) where
%   step (Mk_Add x y) = Add x y

% instance (HRep_Mul down Exp) where
%   step (Mk_Mul x y) = Mul x y
% \end{code}

% \begin{code}
% instance (f otimes n down Exp) where
%   step (Freq f) = step f
% \end{code}

% \begin{code}
% instance Arbitrary1 (f otimes n) where
%   liftArbitrary gen_HRep = Tag <$> gen_HRep
% \end{code} %$

% instance (Term f down Exp) where
%   step (TagTerm f) = step f
% \end{code}

% \begin{code}
% instance (HRep_ten down Exp) where
%   step Mk_ten = ten

% instance (HRep_square down Exp) where
%   step (Mk_square x) = square x

% instance (HRep_minus down Exp) where
%   step (Mk_minus x y) = minus x y
% \end{code}

% \begin{code}
% instance Arbitrary1 HRep_ten where
%   liftArbitrary gen_HRep = pure Mk_ten

% instance Arbitrary1 HRep_square where
%   liftArbitrary gen_HRep = Mk_square <$> gen_HRep

% instance Arbitrary1 HRep_minus where
%   liftArbitrary gen_HRep
%     = Mk_minus <$> gen_HRep <*> gen_HRep
% \end{code} %$

% \begin{code}
% instance (HRep_foo_1 down Exp) where
%   step (Mk_foo_1 x y)
%     = Add (Add x (Val 50)) (Add (Val 25) y)

% instance (HRep_foo_2 down Exp) where
%   step (Mk_foo_2 x y)
%     = Mul (Val 50) (Mul (Val x) y)
% \end{code}

% \begin{code}
% instance Arbitrary1 HRep_foo_1 where
%   liftArbitrary gen_HRep
%     = Mk_foo_1 <$> gen_HRep <*> gen_HRep

% instance Arbitrary1 HRep_foo_2 where
%   liftArbitrary gen_HRep
%     = Mk_foo_2 <$> arbitrary <*> gen_HRep
% \end{code} %$

% \begin{code}
% instance (f oplus g down Exp) where
%   step (L f) = step f
%   step (R g) = step g
% \end{code}

% \begin{code}
% instance Arbitrary1 (f oplus g) where
%   liftArbitrary gen_HRep
%     = frequency
%       [ (freq at_f, L <$> gen_HRep)
%       , (freq at_g, R <$> gen_HRep) ]
% \end{code} %$
\section{Random Generators Synthesis} \label{sec:synthesis}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.
% %include sections/casestudies.tex
\section{Related Work}

Aliquam erat volutpat. Nunc eleifend leo vitae magna. In id erat non orci
commodo lobortis. Proin neque massa, cursus ut, gravida ut, lobortis eget,
lacus. Sed diam. Praesent fermentum tempor tellus. Nullam tempus. Mauris ac
felis vel velit tristique imperdiet. Donec at pede. Etiam vel neque nec dui
dignissim bibendum. Vivamus id enim. Phasellus neque orci, porta a, aliquet
quis, semper a, massa. Phasellus purus. Pellentesque tristique imperdiet tortor.
Nam euismod tellus id erat.
\section{Final Remarks}

Nullam eu ante vel est convallis dignissim. Fusce suscipit, wisi nec facilisis
facilisis, est dui fermentum leo, quis tempor ligula erat quis odio. Nunc porta
vulputate tellus. Nunc rutrum turpis sed pede. Sed bibendum. Aliquam posuere.
Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
varius mi purus non odio. Pellentesque condimentum, magna ut suscipit hendrerit,
ipsum augue ornare nulla, non luctus diam neque sit amet urna. Curabitur
vulputate vestibulum lorem.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
\bibliographystyle{IEEEtran}
\bibliography{references.bib}

\end{document}
