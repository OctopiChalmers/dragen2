\section{Introduction}

% Scenario of random testing
Random testing is a promising approach for finding bugs
\cite{HughesNSA16,HughesPAN16,ArtsHNS15}.
%
\quickcheck \cite{ClaessenH00} is the dominant tool of this sort used by the
Haskell community.
%
It requires developers to specify (i) \emph{testing properties} describing
programs' expected behavior and (ii) \emph{random data generators} based on the
\emph{types} of the expected inputs (e.g., an integer, an string,
etc.). %, e.g., an integer, an string, or an abstract data type (ADT).
%
\quickcheck then generates random test cases and reports violating testing
properties.


% Situation with Quick Check, ADTs, tools
\quickcheck comes equipped with random generators for built-in types, while it
requires to manually write generators for user-defined ADTs.
%
Recently, there has been a proliferation of tools to automatically derive
\quickcheck generators for ADTs
\cite{mitchell2007,RuncimanNL08,DuregardJW12,grieco2017,DBLP:conf/haskell/MistaRH18}.
%
The main difference about these tools lies on the guarantees provided to ensure
\emph{the termination of the generation process} and the \emph{distribution of
  random values}.
%
Despite their differences, these tools guarantee that generated values are
\emph{well-typed}.
%
In other words, generated values follow the structure described by ADT
definitions.


%% How to use random generated ADTs
Well-typed ADT values are specially useful when testing programs which expect
highly structured inputs like compilers \cite{Palka11,MidtgaardJKNN17}.
%
Generating ADT values also proves fruitful when looking for vulnerabilities in
combination with fuzzers \cite{GriecoCB16,grieco2017}.
%
%% Problem
%
Despite these success stories, ADT type-definitions do not often capture all the
invariants expected from the data that they are intended to model.
%
As a result, even if random values are well-typed, they might not be built with
enough structure to penetrate into deep software layers.


%% Our proposal
In this work, we identify two different sources of structural information that
can be statically exploited to improve the generation process of ADT values
(Section \ref{sec:sources}).
%
% In this work, we propose a novel improvement in the generation process of ADT
% values by exploiting some static information found in the codebase.
%
Then, we show how to capture this information into our (automatically) derived
random generators.
%
More specifically, we propose a generation process that is capable of
considering how programs branch on input ADTs values as well as how they get
manipulated by abstract interfaces (Section \ref{sec:hrepcont}).
%
Furthermore, we show how to predict the \emph{expected} distribution of the ADT
constructors, values fitting certain branching patterns, and calls to interfaces
that our random generators produce.
%
For that, we extend some recent results on applying \emph{branching
  processes}\cite{gw1875}---a simple stochastic model conceived to study
population growth (Section \ref{sec:synthesis}).
%
%---to predict the distribution of QuickCheck
%generators\cite{DBLP:conf/haskell/MistaRH18}.
%
We implement our ideas in a tool called \dragenp\footnote{\dragenp is available
  at \url{http://github.com/OctopiChalmers/dragen-struct}}, that is capable of
automatically synthesizing \quickcheck generators which produce \emph{rich ADT
  values}, where the distributions of random values can be adjusted at
compile-time to what developers might want. %based on our predictions.
%
Finally, we provide empirical evaluations showing that including static
information from the user codebase improves the code coverage of two external
applications when tested using random values generated following our ideas
(Section \ref{sec:casestudies}).

% \todo[inline,author=Ale]{Add here later about test cases when we know what they
%   are}

We remark that, although this work focuses on Haskell algebraic data types, this
technique is general enough to be applied to most programming languages.
%
%with some level of support for composite types.

% The main contribuitions of this paper are:
% %
% \begin{itemize}
%   %
% \item We identify two patological scenarios for which standard type-driven
%   automatic derivation tools fail to synthesize practical random generators, due
%   to a lack of either type structure or domain knowleadge (Section
%   \ref{sec:randomtesting}).
%   %
% \item We present a generation technique able to encode stronger properties of
%   the target data type by reifying the static information present on the program
%   codebase (Section \ref{sec:hrep}).
%   %
% \item We apply and extend the theory of branching processes to analitically
%   predict the average distribution of generated values.
%   %
%   Furthermore, we use the predictions to perform simulation-based optimization
%   of the random generation parameters (Section \ref{sec:synthesis}).
%   %
% \item We provide an implementation of our ideas in the form of a Haskell library
%   to perform automatic derivation of random generators capable to extract useful
%   structure information from the user source code.
%   %
% \end{itemize}

% Local Variables:
% TeX-master: "main.lhs.tex"
% TeX-command-default: "Make"
% End:
