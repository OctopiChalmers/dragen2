{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeOperators #-}

module Expr where

import Test.QuickCheck

import Test.QuickCheck.Patterns.Rep
import Test.QuickCheck.Patterns.TH

data Expr a
  = ELit a
  | EAdd (Expr a) (Expr a)
  | EMul (Expr a) (Expr a)
  | EMbE (Maybe (Maybe (Expr a)))
  | ELst [Expr a]
  | EVar String
  deriving Show

foo :: Int -> Expr a -> Int -> a
foo 1 (EAdd (EVar "foo") (ELit _)) = undefined
foo 2 (EMul (ELit _) _)            = undefined
foo 3 (EMul (ELit _) _)            = undefined
foo _ _                            = undefined

bar :: Expr Int -> Bool
bar (EMul (EAdd _ _) _)         = undefined
bar (EAdd _ (EAdd _ (ELit 42))) = undefined
bar _                           = undefined

baz :: Expr a -> Bool
baz (EMul (EAdd _ (ELit _)) (EVar "baz")) = undefined
baz (EAdd _ (EAdd _ (ELit _)))            = undefined
baz (EMbE (Just _))                       = undefined
baz _                                     = undefined

deriveAll ''Expr [''Int] [('foo, 2), ('bar, 1), ('baz, 1)]

-- derivePF ''Expr
-- deriveFunPF 'foo [''Int]
-- deriveFunPF 'bar []
-- deriveFunPF 'baz [''Int]

instance Arbitrary a => Arbitrary1 (ExprF a) where
  liftArbitrary gen = sized $ \n ->
    if n == 0
    then oneof
         [ (ELitF <$> arbitrary)
         , (EVarF <$> arbitrary) ]
    else oneof
         [ (ELitF <$> arbitrary)
         , (EAddF <$> resize (n-1) gen <*> resize (n-1) gen)
         , (EMulF <$> resize (n-1) gen <*> resize (n-1) gen)
         , (EMbEF <$> liftArbitrary (liftArbitrary (resize (n-1) gen)))
         , (ELstF <$> liftArbitrary (resize (n-1) gen))
         , (EVarF <$> arbitrary) ]

instance Arbitrary a => Arbitrary1 (Pat_foo a) where
  liftArbitrary gen
    = oneof
    [ Pat_foo_1 <$> arbitrary
    , Pat_foo_2 <$> arbitrary <*> gen `suchThat` const True
    , Pat_foo_3 <$> arbitrary <*> gen `suchThat` const True ]

instance Arbitrary1 Pat_bar where
  liftArbitrary gen
    = oneof
    [ Pat_bar_1 <$> gen <*> gen <*> gen
    , Pat_bar_2 <$> gen <*> gen `suchThat` const True ]

instance Arbitrary a => Arbitrary1 (Pat_baz a) where
  liftArbitrary gen
    = oneof
    [ Pat_baz_1 <$> gen <*> arbitrary
    , Pat_baz_2 <$> gen <*> gen <*> arbitrary `suchThat` const True
    , Pat_baz_3 <$> liftArbitrary gen `suchThat` const True ]


type Expr_Int_foo_bar = Interleave (Expr Int) [Pat "foo" :> 5, Pat "bar"]

genExpr :: Gen Expr_Int_foo_bar
genExpr = arbitrary



main :: IO ()
main = return ()

-- --------------------------------
-- -- Autogenerated code

-- data ExprF a r
--   = ELitF a
--   | EAddF r r
--   | EMulF r r
--   | EVarF String
--   deriving Functor

-- instance Algebra (ExprF a) (Expr a) where
--   alg (ELitF n)     = ELit n
--   alg (EAddF e1 e2) = EAdd e1 e2
--   alg (EMulF e1 e2) = EMul e1 e2
--   alg (EVarF v)     = EVar v

-- type instance PF (Expr a) = (ExprF a)

-- instance Rep (ExprF a) (Expr a)

-- data Pat_foo a t
--   = Pat_foo_1 a
--   | Pat_foo_2 a t
--   | Pat_foo_3 a t
--   deriving Functor

-- instance FAlgebra (Pat_foo a) (Expr a) where
--   alg (Pat_foo_1 n)   = EAdd (EVar "a") (ELit n)
--   alg (Pat_foo_2 a e) = EMul (ELit a) e
--   alg (Pat_foo_3 a e) = EMul (ELit a) e

-- data Pat_bar a t
--   = Pat_bar_1 t t t
--   | Pat_bar_2 t t a
--   deriving Functor

-- instance FAlgebra (Pat_bar a) (Expr a) where
--   alg (Pat_bar_1 e1 e2 e3) = EMul (EAdd e1 e2) e3
--   alg (Pat_bar_2 e1 e2 n)  = EAdd e1 (EAdd e2 (ELit n))

-- type instance Pattern "foo" = Pat_foo Int
-- type instance Pattern "bar" = Pat_bar
-- type instance Pattern "baz" = Pat_baz Int

-- ----------------------------------------
-- -- Code to tell our tool how to behave

-- type Expr_Int_foo_bar_baz = Interleave (Expr Int) '["foo", "bar", "baz"]


  -- '["foo", "bar", "baz"]

-- x :: Expr_Int_foo_bar_baz
-- x = rnd $ EAddF
--       (rnd $ ELitF 5)
--       (rnd $ ELitF 10)

-- y :: Expr_Int_foo_bar_baz
-- y = pat2 $ Pat_bar_1
--       (rnd $ ELitF 42)
--       (pat3 $ Pat_baz_3
--         (rnd $ EVarF "Hey"))
--       (pat1 $ Pat_foo_2
--          10
--          (rnd $ EVarF "Ho"))

-- y :: Expr_Int_foo_bar_baz
-- y = pat2 $ Pat_bar_1
--       (rnd $ ELitF 42)
--       (rnd $ ELitF 42)
--       (rnd $ ELitF 42)


-- x' :: Expr Int
-- x' = eval x

-- y' :: Expr Int
-- y' = eval y
