\section{Unified Representation of Constructions}
\label{sec:representation}

% --------------------------------------
% The basic idea
%
This section introduces a unified representation for the different constructions
we might want to consider when generating random values.
%
The key idea of this work is to lift each different source of structural
information into the type level.
%
In this light, the ``shape'' of our random data is determined entirely by
the type we use to represent it during the generation process.
%
For this, we will define a set of different simple ``open'' data types,
each one in charge of representing a single construction of our target data
type.
%
These types can be later
\begin{inparaenum}[(i)]
\item combined in several ways depending on the desired shape of our test data,
\item randomly generated (see Section \ref{sec:generators}), and finally,
\item transformed back into the corresponding values of the target data type
  automatically.
\end{inparaenum}
%
This lifted representation of constructions can be automatically derived from
our source code in compile-time, relieving programmers of the burden of manually
implementing this required machinery.


% --------------------------------------
% Representing data constructors
%
\subsection{Representing Data Constructors}

When generating values of algebraic data types, the simplest piece of meaningful
information we ought to consider is the one given by each one of its data
constructors.
%
\footnote{We explicitly avoid considering $\bot$ when generating random values.}
%
In this light, each individual data constructor of the target data type can be
represented simply by a new data type with a single constructor.
%
Recalling our |Html| example, its data constructors can be represented as
follows:

\begin{code}
data Con_Text   r = Con_Text  String
data Con_Sing   r = Con_Sing  String
data Con_Tag    r = Con_Tag   String r
data Con_Join   r = Con_Join  r r
\end{code}
%
In the previous definitions, each representation has the same fields as its
corresponding constructor, except for the recursive ones which are abstracted
away using a type parameter |r|.
%
This parametricity lets us leave the type of each recursive sub-term unspecified
until we have decided the overall shape of our random data.
%
Then, for instance, the value |Con_Tag "div" x :: Con_Tag y| represents the
|Html| value |Tag "div" x|, for some sub-term |x :: y| that can be transformed
back to |Html| as well.
%
It is easy to note how each one of these simple representations encode the
minimal amount of information they need, leaving everything else unspecified.

An important property of these parametric representations is that, in most
cases, they form a functor over its type parameter, and thus we can use
Haskell's |deriving| mechanism to obtain a suitable |Functor| instances for
free:

\begin{code}
deriving instance Functor Con_Text
deriving instance Functor Con_Sing
deriving instance Functor Con_Tag
deriving instance Functor Con_Join
\end{code}


% --------------------------------------
% F-Algebras
%
Then, the next building block of our approach consists of providing a mapping
from each constructor representation to its actual target value, provided that
each recursive sub-term has already been translated to its corresponding target
value.
%
Categorically, this is often referred as an F-Algebra over the functor we use to
encode our different constructions.
%
We will represent this mapping defining a type class |Algebra| with a single
method |alg| as follows:

\begin{code}
class Functor f => Algebra f a | f -> a where
  alg :: f a -> a
\end{code}
%
In the previous definition, |f| is the functor type used to represent a
construction of the target type |a|.
%
Note the functional dependency |f -> a|, helping the type checker to solve the
free type variable |a| at the right hand side of the |=>|.
%
In practical terms, it ensures that each representation type |f| will be
translated to a unique target type |a|.
%
Then, we need to instantiate this type class for each data constructor
representation we are considering, providing an appropriate implementation for
the overloaded |alg| function.
%
To do so we can simply transform each representation into its corresponding
value by picking its analogous data constructor, and piping its fields
unchanged:

\begin{code}
instance Algebra Con_Text Html where
  alg (Con_Text x) = Text x

instance Algebra Con_Sing Html where
  alg (Con_Sing x) = Sing x

instance Algebra Con_Tag Html where
  alg (Con_Tag t x) = Tag t x

instance Algebra Con_Join Html where
  alg (Con_Join x y) = Join x y
\end{code}
%
Note how every definition regarding each different representation so far was
obtained rather mechanically.
%
This let us automate the process quite a bit using Haskell's meta-programming
capabilities.


% --------------------------------------
% Generic sums
%
\subsection{Composing Representations}

So far we have seen how to represent each data constructor of our |Html| data
type independently.
%
In order to represent interesting values, we need to be able to combine these
single representations into (possibly complex) composite ones.
%
For this purpose, we will define a generic functor type |oplus| to encode the
choice between two given representation types as follows:

\begin{code}
data ((f :: * -> *) oplus'' (g :: * -> *)) r = InL (f r) | InR (g r)

instance (Functor f, Functor g) => Functor (f oplus'' g)
  where  fmap h (InL f) = InL (fmap h f)
         fmap h (InR g) = InR (fmap h g)

\end{code}
%
This infix type-level operator let us combine two representations |f| and |g|
into a composite one |f oplus'' g|, representing either a value from |f| (via
the |InL| constructor) or a value from |g| (via the |InR| constructor).
%
This operator works pretty much in the same way as Haskell's |Either| data type,
except that, instead of combining two base types, it works combining two
\emph{parametric type constructors}, hence the kind signature |* -> *| in both
|f| and |g|.
%
For instance, we can use the type |Con_Text oplus'' Con_Tag| to encode values
representing either plain text HTMLs or paired tags.
%
Such values can be constructed easily using the injections |InL| and |InR| on
each each case, respectively.


The next step consists of providing an |Algebra| type instance for composite
representations, provided that each side of the sum can be translated back to
the same target type:

\begin{code}
instance (Algebra f a, Algebra g a) => Algebra (f oplus'' g) a
  where  alg (InL f) = alg f
         alg (InR g) = alg g
\end{code}

In the previous definition, we simply use the appropriate |Algebra| instance for
the inner representation, based on which injection was used to construct the
composite value.
%
It is worth remarking that this instance also lets us handle multiple
compositions transparently, i.e., for every set of types |f1|, |f2|, ..., |fk|
representing a target type |t| and having suitable |Algebra| type instances,
then the composition |f1 oplus'' f2 oplus'' dots oplus'' fk| can be mapped back
to |t| using this same mechanism.
%
Additionally, the order in which we associate each operand of |oplus| results
irrelevant, thus we can omit parentheses when describing composite
representations.
%
For simplicity, we will assume |oplus| as having rigth associativity, i.e., |f
oplus'' g oplus'' h == f oplus'' (g oplus'' h)|.


% --------------------------------------
% Fixed points
%
\subsection{Tying the Knot}

Even though we have already seen how to encode single and composite
representations for our target data types, there is as piece of machinery still
missing: our representations are not recursive, but parametric on its recursive
fields.
%
We can think of them as a encoding a single ``layer'' of our target data.
%
In order to represent recursive values we need to close them ``tying the knot''
recusively, i.e., once we have decided the final representation of our target
data, we want each one of its recursive fields to be instantiated with itself.
%
This can be easily achieved by using a type-level fixed point operator:

\begin{code}
data Fix (f :: * -> *) = Fix { unFix :: (f (Fix f)) }
\end{code}
%
Given a parametric type |f| of kind |* -> *| representing some target data type,
the type |Fix f| instantiates each recursive field of |f| with |Fix f|, thus
closing the definition of |f| into itself---note thus that the kind of |Fix f|
results |*|.

In general, if |f| is a representation for a given target type, we will refer to
|Fix f| as a \emph{final representation}, since it cannot be further combined or
extended---the |oplus| operator has to be applied \emph{within} the |Fix| type
constructor.


The effect of a fixed point combinator is much easier to interpret considering
an example.
%
Let us imagine we want to represent our |Html| data type using all of its data
constructors.
%
For this purpose we use the following type to represent it:

\begin{code}
type Html' = Con_Text oplus'' Con_Sing oplus'' Con_Tag oplus'' Con_Join
\end{code}
%
Then, for instance, the value:

\begin{code}
  x :: Html
  x = Join (Text "hello") (Sing "hr")
\end{code}
%
can be represented with |Html'| as:

\begin{code}
  x' ::  Fix Html'
  x' =   Fix  (InR (InR (InR (Con_Join
              (Fix (InL (Con_Text "hello")))
              (Fix (InR (InL (Con_Sing "hr"))))))))
\end{code}
%
Where the sequences of |InL| and |InR| data constructors inject each value from
an individual representation into the appropriate position of our composite
representation |Html'|.


Finally, given the value |x' :: Fix Html'|, we can evaluate it back to its
corresponding |Html| value as follows:

\begin{code}
eval :: Algebra f a => Fix f -> a
eval = alg . fmap eval . unFix
\end{code}
%
This function exploits the |Functor| structure of our representations,
unwrapping the fixed points and mapping their algebras to the result of
evaluating recursively each recursive sub-term.
%
This recusion schema using functors and F-Algebras to fold data generically has
been well studied and is known categorically a \emph{catamorphism}.

In our particular example, this function satisfies the equation |eval x' == x|.
%
More specifically, one can prove that the types |Html| and |Fix Html'| are in
fact isomorphic, with |eval| as the witness of one side of this
isomorphism---though this is not usually the case for every representation we
choose for our data.


% --------------------------------------
% Representing other constructions
%
\subsection{Representing Additional Constructions}

The representation mechanism we have developed so far let us determine the shape
of our target data based on the type we use to represent it.
%
However, if we only use it to represent data types based solely on their data
constructors, then it is hardly useful for performing random testing, as it only
adds unnecessary complexity to the random generation process.
%
It is not until we start considering more complex constructions that this
approach becomes particularly appealing.

%
% Abstract interfaces
%
Fistly, let us consider the case of generating values obtained by abstract
interface functions.
%
If we recall our |Html| example, we can observe that it is possible to use the
functions on its abstract interface to obtain |Html| values based on different
input arguments:

\begin{code}
br     ::                        Html
bold   ::     Html   ->          Html
list   ::  [  Html]  ->          Html
(<+>)  ::     Html   -> Html ->  Html
\end{code}

Fortunately, it is easy to extend our approach to incorporate the interesting
structure arising from these functions into our representations.
%
As before, we first need to define a set of simple data types to encode each
construction:

\begin{code}
data Fun_br     r = Fun_br
data Fun_bold   r = Fun_bold r
data Fun_list   r = Fun_list [r]
data Fun_cat    r = Fun_cat  r r
\end{code}
%
Each one of these data types represents a value resulting from evaluating its
corresponding function, using as input arguments the values encoded in its
fields.
%
Once again, we replace each recursive field (representing a recursive input
argument) with a type parameter |r| in order to leave the type of the recursive
sub-terms unspecified until we have decided the overall shape of our data.


Note that, by representing values obtained from function application this way,
we are not performing any actual computation---we simply store the functions'
input arguments.
%
Instead, the actual functions are evaluated when transforming our
representations back to their target type, again by the means of an |Algebra|:

\begin{code}
instance Algebra Fun_br Html where
  alg Fun_br = br

instance Algebra Fun_bold Html where
  alg (Fun_bold x) = bold x

instance Algebra Fun_list Html where
  alg (Fun_list xs) = list xs

instance Algebra Fun_cat Html where
  alg (Fun_cat x y) = x <+> y
\end{code}
%
In the previous |Algebra| instances, we simply return the result of evaluating
the appropriate functions, using each representation field as an input argument.


It is important to remark that this approach inherits any possible downside from
the functions we use to represent our target data.
%
In particular, using non-terminating functions to represent our data might
produce a non-terminating behavior when calling to the |eval| function.


%
% Functions pattern matchings
%
The second source of structural information that we consider in this work is the
one present in functions' pattern matchings.
%
If we recall to our |simplify| from Section \ref{sec:sources}, we can observe it
has two complex, non-trivial patterns that we might want to satisfy when
generating random values:

\begin{code}
simplify (Join (Text t1) (Text t2))   = dots
simplify (Join (Join (Text t1) x) y)  = dots
\end{code}

We can extend our approach further in order to represent these patterns as well.
%
We start defining single data types for each one of them, this time encoding in
the fields of each single data constructor the free pattern variables (or
wildcards) appearing in corresponding patterns from left to right:

\begin{code}
data Pat_simplify_1 r = Pat_simplify_1 String String
data Pat_simplify_2 r = Pat_simplify_2 String r r
\end{code}
%
Where the number after the |#| simply distinguishes the different patterns from
the function |simplify| using the index of the clause they belong to.
%
Once again, we abstracted away every recursive field (this time corresponding to
a recursive pattern variable or wildcard) using a type variable |r| until we
have decided the overall shape of our target data.


Then, the task of our |Algebra| instances is to expand each pattern
representation into the corresponding target value resembling such pattern,
where each pattern variable gets instantiated using the values stored in its
representation fields:

\begin{code}
instance Algebra Pat_simplify_1 Html where
  alg (Pat_simplify_1 t1 t2) = Join (Text t1) (Text t2)

instance Algebra Pat_simplify_2 Html where
  alg (Pat_simplify_1 t x y) = Join (Join (Text t) x) y
\end{code}


%
% Closing
%
Using this extensions, we are now able to represent values of our target data
using a higher abstraction level.
%
Instead of constructing values solely by combining different data constructors,
this mechanism lets us also consider complex constructions like computing
abstract interface functions and functions' patterns, treating them uniformingly
and in a fine grained fashion.


As we have introduced in the Section \ref{sec:sources}, having an extensible,
fine-grained framework for generating random data might be of great advantage,
as we would like to generate random test cases following different strategies
when testing different properties.
%
For instance, generating values satisfying the pattern matchings of the function
|simplify| could be relevant only when testing properties involving such
function.
%
For this purpose, we could represent |Html| values as follows:
%
\begin{code}
type Html_simplify  =      Con_Text oplus'' Con_Sing oplus'' Con_Tag oplus'' Con_Join
                    oplus  Pat_simplify_1 oplus'' Pat_simplify_2
\end{code}


%
Furthermore, if we want to test properties expecting valid |Html| values as
inputs, we could avoid generating random |Sing| and |Tag| data constructors, as
they might represent invalid tags.
%
Instead, we could specify that our random data can be constructed using only
``safe'' constructions, using perhaps a representation type like follows:

\begin{code}
type ValidHtml = Con_Text oplus'' Con_Join oplus'' Fun_br oplus'' Fun_bold
\end{code}


The next section introduces a generic way to generate random values from our
different representations, extending them with a set of type-level combinators
to encode information relevant to the generation process directly on their
types.
