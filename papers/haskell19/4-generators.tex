\section{Generating Random Constructions}
\label{sec:generators}

% --------------------------------------
% Intro
%
So far we have seen how to encode different random constructions representing
interesting values from our target data types.
%
Such representations follow a modular approach, where each construction is
independent from the rest.
%
This modularity allows us to derive each different construction individually, as
well to specify the shape of our target data with a fine granularity.


In this section, we introduce the machinery required to randomly generate the
values encoded using our representations.
%
This step also follows the modular fashion, resulting in a generation process
entirely compositional.
%
In this light, our random generators are built from smaller ones (each one
representing a single random construction), and are solely based on the types we
use to represent the shape of our random data.


Ideally, our aim is to be able to obtain random generators with a behavior
similar to the one presented for |Html| in Section \ref{sec:intro}.
%
If we take a closer look at its definition, there we can observe three factors
happening simultaneously:
%
\vspace{2pt}
\begin{CompactItemize}
\item We use QuickCheck's generation size to limit the depth of the generated
  values, reducing it by one on each recursive call of the local auxiliary
  function |gen|.
\item We differentiated between \emph{terminal} and \emph{non-terminal
    constructors}, picking only among terminal ones when we have reached the
  maximum depth (case |gen 0|).
\item We generate different constructions in a (possibly) different frequency.
\end{CompactItemize}
%
For the rest of this section, we will focus on modeling these aspects in our
modular framework, in such a way that does not compromise the compositionality
obtained so far.


% --------------------------------------
% Depth-bounded generators
%
\subsection{Depth-Bounded Modular Generators}

The first obstacle that arises when trying to generate random values with a
limited depth using our approach is related to modularity.
%
If we recall the random generator for |Html| from Section \ref{sec:intro}, we
can observe that the depth parameter |d| is threaded to the different recursive
calls of our generator, always within the scope of the local function |gen|.
%
Since each construction will have an specialized random generator, we cannot
group them as we did before using an internal |gen| function.
%
Instead, we will define a data type for depth-bounded generators, wrapping
QuickCheck's |Gen| data type with a external parameter representing the current
maximum recursive depth:

\begin{code}
type BGen a = Int -> Gen a
\end{code}
%
A |BGen| is, essentially, a normal QuickCheck |Gen| with the maximum recursive
depth as an input parameter.
%
Using this definition, we can generalize QuickCheck's |Arbitrary| class to work
with depth-bounded generators simply as follows:

\begin{code}
class BArbitrary (a :: *) where
  barbitrary :: BGen a
\end{code}


From now on, we will use this type class as a more flexible substitute of
|Arbitrary|, given that now we have two parameters to tune: the maximum
recursive depth, and the QuickCheck generation size.
%
The former is useful to tune the overall size of our random data, whereas the
latter can be used for tuning the values of the ``leaves'', such as the maximum
length of random |String| or the biggest/smallest random |Int|s.


Here we want to actively remark that, even though we could have used the
QuickCheck generation size parameter to simultaneously model the maximum
recursive depth and the maximum size of the leaves, doing so would imply
generating random leaves with a decreasing size as we move deeper within a random
value, obtaining for instance, random trees with all zeroes on its leaves, or
random lists skewed to be ordered in decreasing order.
%
In addition, one can always obtain a trivial |Arbitrary| instance from a
|BArbitrary| one by using QuickCheck's generation size both for the maximum
recursive depth as well as for generating leaves:

\begin{code}
instance BArbitrary MyType => Arbitrary MyType where
  arbitrary = sized barbitrary
\end{code} %$


Even though we have extended QuickCheck's generators to be depth-aware, here we
also need to consider the parametric nature of our representations.
%
In the previous section, we defined each construction representation as being
parametric on the type of its recursive sub-terms, as a way to defer this choice
until we have specified the final shape of our target data.
%
Hence, each construction representation is of kind |* -> *|.
%
If we want to define our generators in a modular way, we also need to
parameterize somehow the generation of the recursive sub-terms!
%
If we look at QuickCheck, this library already defines a type class |Arbitrary1|
for parametric types of kind |* -> *|, which solves this issue by receiving the
generator for the parametric sub-terms as an argument:

\begin{code}
class Arbitrary1 (f :: * -> *) where
  liftArbitrary :: Gen a -> Gen (f a)
\end{code}
%
% This type class allows us to write modular generators, leaving unspecified the
% specific generator used when generating values of its type argument.
% %
% For instance, the default parametric generator for the data type |Maybe| looks
% like:
%
% \begin{code}
% instance Arbitrary1 Maybe where
%   liftArbitrary gen = frequency
%     [  (1,  pure Nothing),  (3,  Just <$> gen) ]
% \end{code} %$
%
% Where the random generator use to generate the value stored in a |Just|
% constructor is parametrized by the |gen| input variable.
%
Then, we can use this same mechanism for our modular generators, extending
|Arbitrary1| to be depth-aware as follows:

\begin{code}
class BArbitrary1 (f :: * -> *) where
  liftBGen :: BGen a -> BGen (f a)
\end{code}
%
Note the similarities between |Arbitrary1| and |BArbitrary1|.
%
We will use this type class to implement random generators for each construction
we are considering.
%
Recalling our |Html| example, we can define modular random generators for the
constructions representing data constructors as follows:

\begin{code}
instance BArbitrary1 Con_Text where
  liftBGen bgen d = Mk_Text <$> arbitrary

instance BArbitrary1 Con_Sing where
  liftBGen bgen d = Mk_Sing <$> arbitrary

instance BArbitrary1 Con_Tag where
  liftBGen bgen d = Mk_Tag <$> arbitrary <*> bgen (d - 1)

instance BArbitrary1 Con_Join where
  liftBGen bgen d = Mk_Join <$> bgen (d - 1) <*> bgen (d - 1)
\end{code} %$
%
Note how each instance is defined to be parametric of the maximum depth (using
the input integer |d|) and the random generator used for the recursive sub-terms
(using the input generator |bgen|).
%
Every other non-recursive sub-term can be generated using a normal |Arbitrary|
instance---we use this to generate random |String|s in the previous definitions.


The rest of our representations can be generated analogously.
%
For example, the |BArbitrary1| instances for |Fun_bold| and |Pat_simplify_2| are
as follows:

\begin{code}
instance BArbitrary1 Fun_bold where
  liftBGen bgen d = Mk_bold <$> bgen (d - 1)

instance BArbitrary1 Pat_simplify_2 where
  liftBGen bgen d = Mk_simplify_2
    <$> arbitrary <*> bgen (d - 1) <*> bgen (d - 1)
\end{code} %$

% \begin{code}
% instance BArbitrary1 Fun_br where
%   liftBGen gen d = pure Fun_br

% instance BArbitrary1 Fun_bold where
%   liftBGen gen d = Fun_bold <$> gen (d - 1)

% instance BArbitrary1 Fun_cat where
%   liftBGen gen d = Fun_cat <$> gen (d - 1) <*> gen (d - 1)

% instance BArbitrary1 Fun_list where
%   liftBGen gen d = Fun_list <$> liftArbitrary (gen (d - 1))
% \end{code} %$

% \begin{code}
% instance BArbitrary1 Pat_simplify_1 where
%   liftBGen gen d
%     = Pat_simplify_1 <$> arbitrary <*> arbitrary

% instance BArbitrary1 Pat_simplify_2 where
%   liftBGen gen d
%     = Pat_simplify_2 <$> gen (d - 1) <*> gen (d - 1)
% \end{code}

Having the modular generators for each random construction in place, we can
obtain a concrete depth-aware generator (of kind |*|) for any final
representation |f| as follows:

\begin{code}
instance BArbitrary1 f => BArbitrary (Fix f) where
  barbitrary d = FixC <$> liftBGen barbitrary d
\end{code} %$
%
Here we used the |BArbitrary1| instance of our final representation |f| to
generate sub-terms recursively by lifting itself (|liftBGen barbitrary|) as the
parameterized input generator, wrapping each recursive sub-term with a |FixC|
data constructor.

%
% Wrapping this subsection
%
The machinery developed so far lets us generate single random constructions in a
modular fashion.
%
However, we still need to develop our generation mechanism a bit further in
order to generate composite representations built using the |oplus| operator.
%
This is the objective of the next sub-section.


% --------------------------------------
% Encoding Generation Behavior Using Types
%
\subsection{Encoding Generation Behavior Using Types}

As we have seen so far, generating each representation is rather
straightforward: there is only one data constructor to pick, and every field is
generated using a mechanical recipe.
%
In our approach, most of the generation complexity is encoded in the random
generator for composite representations, built upon the |oplus| operator.
%
Before introducing it, we need to define some additional machinery to encode the
notions of terminal construction and generation frequency.
%
\looseness=-1

Recalling the random generator for |Html| presented in Section \ref{sec:intro},
we can observe that the last generation level (see |gen 0|) is constrained to
generate values only from the subset of terminal constructions.
%
In order to model this behavior, we will first define a data type |Term| to
``tag'' every terminal construction explicitly:

\begin{code}
newtype Term (f :: * -> *) a = TermC (f a)
\end{code}
%
Then, if |f| is a terminal construction, the type |Term f oplus' g| can be
interpreted as representing data generated using values drawn both from |f| and
|g|, but ``closed'' using only values from |f|.
%
Since this data type will not add any semantic information to the represented
values, we can define suitable |Algebra| and |BArbitrary1| instances for it
simply by delegating the work to the inner type:

\begin{code}
instance Algebra f a => Algebra (Term f) a where
  alg (TermC f) = alg f

instance BArbitrary1 f => BArbitrary1 (Term f) where
  liftBGen bgen d = TermC <$> liftBGen bgen d
\end{code} %$


The next building block of our framework consists in a way of specifying the
generation frequency of each construction.
%
For this purpose, we can follow the same reasoning as before, defining a
type-level operator |otimes| to explicitly tag the generation frequency of a
given representation:

\begin{code}
newtype ((f :: * -> *) otimes'' (n :: Nat)) a = FreqC (f a)
\end{code}
%
This operator is parameterized by a type-level natural number |n| (of kind |Nat|)
representing the desired generation frequency.
%
In this light, the type |(f otimes'' 3) oplus'' (g otimes'' 1)| represents data
generated using values from both |f| and |g|, where |f| is randomly chosen three
times more frequently than |g|.
%
In practice, we defined |otimes| such that it associates more strongly than
|oplus|, thus avoiding the need of parenthesis in types like the previous one.
%
Analogously as |Term|, the operator |otimes| does not add any semantic
information to the values it represents, so we can define its |Algebra| and
|BAbitrary1| instance by delegating the work to the inner type as before:

\begin{code}
instance Algebra f a => Algebra (f otimes'' n) a where
  alg (FreqC f) = alg f

instance BArbitrary1 f => BArbitrary1 (f otimes'' n) where
  liftBGen bgen d = FreqC <$> liftBGen bgen d
\end{code} %$


With these two new type level combinators, |Term| and |otimes|, we are now able
to express the behavior of our entire generation process based solely on the
type we are generating.


In addition to these combinators, we will need to perform some type-level
computations based on them in order to define our random generator for composite
representations.
%
Consider for instance the following type---defined using parenthesis for clarity:

\begin{code}
(f otimes'' 2) oplus'' ((g otimes'' 3) oplus'' (Term h otimes'' 5))
\end{code}
%
Our generation process will traverse this type one combinator at a time,
processing each occurrence of |oplus| independently.
%
This means that, in order to select the appropriate generation frequency of each
operand we need to calculate the overall sum of frequencies on each side of the
|oplus|.
%
For this purpose, we can implement a closed type family |FreqOf| to compute the
overall sum of frequencies of a given representation type:

\begin{code}
type family FreqOf (f :: * -> *) :: Nat where
  FreqOf (f oplus'' g)   = FreqOf f + FreqOf g
  FreqOf (f otimes'' n)  = n * FreqOf f
  FreqOf (Term f)        = FreqOf f
  FreqOf _               = 1
\end{code}
%
This type-level function takes a representation type as an input and traverses
it recursively, adding up each frequency tag found in the process, and returning
a type-level natural number.
%
Note how in the second equation we multiply the frequency encoded in the
|otimes| tag with the frequency of the type it is wrapping.
%
This way, the type |((f otimes'' 2) oplus'' g) otimes'' 3| is equivalent to |(f
otimes'' 6) oplus'' (g otimes'' 3)|, following the natural intuition for the
addition and multiplication operations over natural numbers.
%
Moreover, if a type does have an explicit frequency, then its frequency is
simply defaulted to one.


Furthermore, the last step of our generation process, which only generates
terminal constructions, could be seen as considering the non-terminal ones as
having generation frequency zero.
%
This way, we can introduce another type-level computation to calculate the
\emph{terminal generation frequency} |FreqOf'| of a given representation as
follows:

\begin{code}
type family FreqOf' (f :: * -> *) :: Nat where
  FreqOf' (f oplus'' g)   = FreqOf' f  +  FreqOf' g
  FreqOf' (f otimes'' n)  = n  *  FreqOf' f
  FreqOf' (Term f)        = FreqOf f
  FreqOf' _               = 0
\end{code}
%
Similar to |FreqOf|, the type family above traverses its input type adding the
terminal frequency of each sub-type.
%
However, |FreqOf'| only considers the frequency of those representation
sub-types that are explicitly tagged as terminal, returning zero in any other
case.


Then, using the |Term| and |otimes| combinators introduced at the beginning of
this sub-section, along with the previous type-level computations over
frequencies, we are finally in position of defining our random generator for
composite representations:

\begin{code}
instance (BArbitrary1 f, BArbitrary1 g)
  => BArbitrary1 (f oplus g) where
  liftBGen bgen d =
    if d > 0
    then frequency
      [ (freqVal  at(FreqOf f) ,  InL <$> liftBGen bgen d)
      , (freqVal  at(FreqOf g) ,  InR <$> liftBGen bgen d) ]
    else frequency
      [ (freqVal  at(FreqOf' f) ,  InL <$> liftBGen bgen d)
      , (freqVal  at(FreqOf' g) ,  InR <$> liftBGen bgen d) ]
\end{code}
%
Like the generator for |Html| introduced in Section \ref{sec:intro}, this
generator branches over the current depth |d|.
%
In the case we can still generate values from any construction (|d > 0|), we
will use QuickCheck's |frequency| operation to randomly choose between
generating a value of each side of the |oplus|, i.e., either a value of |f| or a
value of |g|, following the generation frequencies specified for both of them,
and wrapping the values with the appropriate injection |InL| or |InR| on each
case.
%
Such frequencies are obtained by \emph{reflecting} the type-level natural values
obtained from applying |FreqOf| to both |f| and |g|, using a type-dependent
function |freqVal| that returns the number corresponding to the type-level
natural value we apply to it:

\begin{code}
freqVal :: forall n dot KnownNat n => Int
\end{code}
%
Note that the type of |freqVal| is ambiguous, since it quantifies over every
possible known type-level natural value |n|.
%
We use a \emph{visible type application} \cite{eisenberg2016visible} (employing
the |at (...)| syntax) to disambiguate to which natural value we are actually
referring to.
%
Then, for instance, the value:

\begin{code}
  freqVal at (FreqOf (f otimes'' 5 oplus' g otimes' 4))
\end{code}
%
evaluates to the concrete value |9 :: Int|.


The |else| clause of our random generator works analogously, except that, this
time we only want to generate terminal constructions, hence we use the |FreqOf'|
type family to compute the terminal generation frequency of each operand.
%
If any of |FreqOf' f| or |FreqOf' g| evaluates to zero, it means that such
operand does not contain any terminal constructions, and |frequency| will not
consider it when generating terminal values.


Moreover, if it happens that both |FreqOf' f| and |FreqOf' g| compute to zero
simultaneously, then this will produce a runtime error triggered by the function
|frequency|, as it does not have anything with a positive frequency to generate.
%
This kind of exceptions will arise, for example, if we forget to tag at least a
one construction from our final representation as terminal.
%
Fortunately, such runtime exceptions can be caught at compile time.
%
We can define a type constraint |HasTerminals| that ensures we are trying to
generate values using a representation with a strictly positive terminal
generation frequency---thus containing at least a single terminal construction:

\begin{code}
type family HasTerminals (f :: * -> *) :: Constraint where
  HasTerminals f = IsPositive (FreqOf' f)

type family IsPositive (n :: Nat) :: Constraint where
  IsPositive 0 = TypeError "No terminals"
  IsPositive _ = ()
\end{code}
%
These type families compute the terminal generation frequency of a
representation type |f|, returning either a type error, if its result is zero;
or, alternatively, an empty constraint |()| that is always trivially satisfied.
%
Finally, we can use this constraint to define a safe generation primitive
|genRep| to obtain a concrete depth-bounded generator for every target type |a|,
specified using a safe representation |f|:

\begin{code}
genRep  :: forall f a dot  ( BArbitrary1 f
                           , HasTerminals f
                           , Algebra f a) => BGen a
genRep d = eval <$> barbitrary at (Fix f) d
\end{code} %$
%
Note how this primitive is also ambiguous in the type used for the
representation.
%
This allows us to use a visible type application to obtain values from the same
target type but generated using different underlying representations, and
avoiding the use of |Proxy| values everywhere.
%
For instance, we can obtain two different concrete generators for our |Html|
type simply by changing its representation type as follows:

\begin{code}
genHtmlPats :: BGen Html
genHtmlPats = genRep at Html_simplify

genValidHtml :: BGen Html
genValidHtml = genRep  at ValidHtml
\end{code}
%
where |Html_simplify| and |ValidHtml| are the representations defined at the end
of Section \ref{sec:representation}.


% --------------------------------------
% Closing
%
So far we have seen how to represent and generate values for our target data
type by combining a wide range of random constructions, as well as a series of
type-level combinators to encode the desired generation behavior.
%
The next section refines our type-level machinery in order to provide a simple
idiom for defining composable random generators.
